import pandas as pd

sample_id_file = pd.read_csv(config["sample_id_file"])
SAMPLE_PREFIX = sample_id_file["sample_name"]
RAW_SEQ_IN = config["raw_seq_in"]


FASTQC_ENV = "fastqc"
##config["fastqc_env"]
MULTIQC_ENV = "multiqc"
##config["multiqc_env"]
CUTADAPT_ENV = "cutadapt"
##config["cutadapt_env"]
BOWTIE_ENV = "bowtie1"
##config["bowtie_env"]
BBMAP_ENV = "bbmap"
##config["bbmap_env"]



rule all:
    input:
        directory("fastqc_outputs"),
        "fastqc_crispr_screen.html",
        expand("cutadapt_outputs/{sample_prefix}_trimmed.fastq.gz",
                sample_prefix = SAMPLE_PREFIX),
        expand("bowtie_unaligned/{sample_prefix}_mismatches_allowed_unaligned.sam",
               sample_prefix=SAMPLE_PREFIX),
        expand("bowtie_aligned/{sample_prefix}_mismatches_allowed.sam",
               sample_prefix=SAMPLE_PREFIX),
        expand("bowtie_aligned/{sample_prefix}_mismatches_allowed.log",
                sample_prefix=SAMPLE_PREFIX),
        expand("bowtie_aligned/{sample_prefix}_mismatches_allowed.err",
                sample_prefix=SAMPLE_PREFIX),
        expand("count_output/{sample_prefix}_counts.txt",
                sample_prefix=SAMPLE_PREFIX),
        expand("count_output/{sample_prefix}_bbpileup.log",
                sample_prefix=SAMPLE_PREFIX),
        expand("count_output/{sample_prefix}_bbpileup.err",
                sample_prefix=SAMPLE_PREFIX)
        




## STEP 0: running fastqc and multiqc
## update everything that should be a path with a forward slash
rule run_fastqc:
    input:
        inDir = RAW_SEQ_IN
    output:
        outDir = directory("fastqc_outputs")
    conda:
        FASTQC_ENV
    params:
        thread_n = 8
    shell:
        """
        echo "running fastqc"

        fastqc {input.inDir}*.fastq.gz -o {output.outDir} --threads {params.thread_n}
        """


rule run_multiqc:
    input:
        inDir = "fastqc_outputs"
    output:
        fastq_report_out = "fastqc_crispr_screen.html"
    conda:
        MULTIQC_ENV
    shell:
        """
        echo "running multiqc"
        
        multiqc -o {input.inDir} --filename {output.fastq_report_out} .
        """

## STEP 1: running cutadapt
## specify how many samples can be run at the same time - config spec. w default 
## may need to use "wildcards" for this
## come in pairs - R1 and R2 put them together as the input 
## outputs 2 fastqs per sample
rule run_cutadapt:
    input:
        ## may want to mask the sample prefix wildcard
        ## update, we don't need this anymore bc the reads are single end  
        ##in_samples = expand("{{sample_prefix}}_{read}_001.fastq.gz", read=["R1", "R2"])
        in_samples = expand("fastqc_outputs/{sample_prefix}_R1_001.fastq.gz",
                             sample_prefix = SAMPLE_PREFIX)
    output:
        out_samples = "cutadapt_outputs/{sample_prefix}_trimmed.fastq.gz"
    conda:
        CUTADAPT_ENV
    params:
        guide_seq = "\"TTGTGGAAAGGACGAAACACCG;min_overlap=10;e=0.2\"",
        guide_length = 20
    shell:
        """
        cutadapt -g {params.guide_seq} \
                 --length={params.guide_length} \
                 -o {output.out_samples} {input.in_samples}
        """


## STEP 2: running bowtie1
## combines cutadapt paired files to one sample file 
rule run_bowtie:
    input:
        in_samples = "cutadapt_outputs/{sample_prefix}_trimmed.fastq.gz",
        bowtie_index = "path/to/human_crispr_sg_brunello"
    output:
        unaligned_out = "bowtie_unaligned/{sample_prefix}_mismatches_allowed_unaligned.sam",
        aligned_out = "bowtie_aligned/{sample_prefix}_mismatches_allowed.sam"
    ## can specify log outputs here
    log:
        log = "bowtie_aligned/{sample_prefix}_mismatches_allowed.log",
        err = "bowtie_aligned/{sample_prefix}_mismatches_allowed.err"
    conda:
        BOWTIE_ENV
    params:
        mismatches = 0
    shell:
        """
        bowtie1 -p 4 \
                {input.bowtie_index} {input.in_samples} \
                -S \
                --no-unal \
                --trim5 0 \
                --trim3 0 \
                --best \
                --strata \
                -m 1 \
                --un {output.unaligned_out} \
                -v {params.mismatches} > {output.aligned_out} \
                1>{log.log} \
                2>{log.err}
        """

## STEP 3: counting guides in bbmap
rule run_bbmap:
    input:
        in_samples = "bowtie_aligned/{sample_prefix}_mismatches_allowed.sam"
    output:
        count_out = "count_output/{sample_prefix}_counts.txt"
    log:
        log = "count_output/{sample_prefix}_bbpileup.log",
        err = "count_output/{sample_prefix}_bbpileup.err"
    conda:
        BBMAP_ENV
    params:
        ## im not sure if we'll need this since the conda install of bbmap doesn't require you to specify pileup.sh
        bbmap_pileup = "bbmap/pileup.sh"
    shell:
     """
     {params.bbmap_pileup} in={input.in_samples} \
                           out={output.count_out} \
                           1>{log.log} \
                           2>{log.err}
     """




        