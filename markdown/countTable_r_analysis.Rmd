---
title: "count_file_wrangling"
output: html_document
date: "2024-10-08"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(broom)
library(magrittr)
library(edgeR)
library(stats)
library(corrplot)
library(corrr)
```

**Functions**
```{r}
## reads in .txt file and adds a column with the sampleid so all table can be combined later 
## don't need this anymore since I do it in bash
add_sampleid <- function(filepath,
                         wanted_sampleid){
  ## reading in file
  counts_table <- read_tsv(filepath) %>% 
    mutate(sampleid = paste(wanted_sampleid))
  return(counts_table)
}

## takes the combined counts table from long to wide format and normalizes it by cpm 
## we only need the plus read columns !!
normalize_table <- function(comb_table,
                            id_col){
  
  if (id_col == 'gene_id') {
    comb_table <- comb_table %>% 
      group_by(gene_id, sampleid) %>% 
      summarise(reads_per_gene = sum(Plus_reads))
    
    reads_col <- 'reads_per_gene'
  } else {
    reads_col <- 'Plus_reads'
  }
  
  ## selected the Plus_reads column
  ## taking the tibble from long to wide format w the sampleids as the columns
  comb_table_wide_df <- comb_table %>% 
                          select(.data[[id_col]], .data[[reads_col]], sampleid) %>% 
                          spread(sampleid, .data[[reads_col]]) %>% 
                          remove_rownames() %>% 
                          column_to_rownames(var = id_col)
  
  comb_table_wide_df["sum_cols"] <- rowSums(comb_table_wide_df)
  comb_table_wide_df <- subset(comb_table_wide_df,
                               sum_cols != 0,
                               select = -sum_cols)
  
  ## cpm won't work if the data frame contains any categorical values 
  norm_combTable_df <- edgeR::cpm(comb_table_wide_df)
  norm_combTable_df <- as.data.frame(norm_combTable_df)
  
  ## creating a list of outputs
  my_list <- list(NonNormTable = comb_table_wide_df,
                  NormTable = norm_combTable_df)
  return(my_list)
}

## takes normalized counts table and conducts a pca analysis
## outputs the pca table and plot
run_pca <- function(norm_df,
                    sample_col,
                    fill_by_col,
                    point_size,
                    point_alpha,
                    brewer_palette,
                    legend_title,
                    plot_title){
  ## running principal component analysis 
  count_pca_results <- prcomp(t(norm_df),
                              center = TRUE,
                              scale. = TRUE)

  ## pulling actual PCA values out of the object
  count_pca_table <- count_pca_results$x %>% 
    as_tibble(rownames = sample_col)
  
  ## pulling out variance explained for PC1 and PC2
  ## want to pull out the proportion of variance 
  pre_varExp <- summary(count_pca_results)
  pca_varExp <- pre_varExp$importance[2,]
  
  x_lab <- paste0('PC1', '(', as.character(round(pca_varExp[1], digits = 4) * 100), '%)')
  y_lab <- paste0('PC2', '(', as.character(round(pca_varExp[2], digits = 4) * 100), '%)')
  
  ## building actual PCA plot using above data
  pca_plot <- count_pca_table %>% 
    ggplot(aes(x = PC1, y = PC2)) +
    geom_point(aes(fill = .data[[fill_by_col]]), 
               pch = 21, 
               size = point_size, 
               alpha = point_alpha) +
    theme_bw(base_size = 20) +
    scale_fill_brewer(palette = brewer_palette,
                      name = legend_title) +
    labs(x = x_lab,
         y = y_lab,
         title = plot_title)
  ## creating list of outputs 
  my_list <- list(PCATable = count_pca_table,
                  PCAPlot = pca_plot)
  return(my_list)
}

## calculates the total amount of sgRNA/gene counts per sample and creates a plot
## idk if this will be by biological group instead of sample in the future...
run_total_counts <- function(comb_table,
                             sum_col,
                             bar_alpha,
                             brewer_palette,
                             x_label,
                             y_label,
                             plot_title){
  ## calculating total counts per sample
  total_counts_table <- comb_table %>% 
    select(.data[[sum_col]], Plus_reads) %>% 
    group_by(.data[[sum_col]]) %>% 
    summarize(total_counts = sum(Plus_reads))
  
  ## building total counts plot
  total_counts_plot <- total_counts_table %>% 
    ggplot(aes(x = .data[[sum_col]], y = total_counts)) +
    geom_bar(aes(fill = .data[[sum_col]]), 
             stat = 'identity', 
             color = 'black', 
             alpha = bar_alpha) +
    theme_bw(base_size = 20) +
    scale_fill_brewer(palette = brewer_palette,
                      guide = 'none') +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = x_label,
         y = y_label,
         title = plot_title)
  ## creating a list of outputs
  my_list <- list(TotalCountTable = total_counts_table,
                  TotalCountPlot = total_counts_plot)
  return(my_list)
}

## transforms all counts in the Plus_reads column by log2 and builds a plot
run_transform_counts <- function(comb_table,
                                 x_axis_col,
                                 bar_alpha,
                                 brewer_palette,
                                 x_label,
                                 y_label,
                                 plot_title){
  ## log2 transformation
  transform_count_table <- comb_table %>% 
    mutate(log2_counts = log2(Plus_reads))
  
  ## plot 
  transform_count_plot <- transform_count_table %>% 
    ggplot(aes(x = .data[[x_axis_col]], y = log2_counts)) +
    geom_boxplot(aes(group = .data[[x_axis_col]]), width = 0.5, color = 'black') +
    geom_violin(aes(fill = .data[[x_axis_col]]), color = 'black', alpha = bar_alpha) +
    theme_bw(base_size = 20) +
    scale_fill_brewer(palette = brewer_palette,
                      guide = 'none') +
    theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
    labs(x = x_label,
         y = y_label,
         title = plot_title)
  ## creating list of outputs
  my_list <- list(TransformCountTable = transform_count_table,
                  TransformCountPlot = transform_count_plot)
  return(my_list)
}

## runs correlation analysis on non-normalized counts data and creates a heat map of results
run_correlation <- function(wide_count_df,
                            corr_method,
                            text_size,
                            legend_barheight,
                            legend_text_size,
                            legend_box_spacing){
  ## running correlation analysis
  corr_matrix <- cor(wide_count_df,
                     method = corr_method)

  proc_corr_matrix <- corr_matrix %>% 
    as_tibble(rownames = 'group1') %>% 
    gather(-group1, key = 'group2', value = 'corr_value')
  
  ## creating plot 
  corr_plot <- proc_corr_matrix %>% 
    ggplot(aes(x = group1, y = group2)) +
    geom_tile(color = 'black', fill = 'white') +
    theme_bw(base_size = 20) +
    geom_text(aes(label = round(corr_value, digits = 2), color = corr_value), 
              size = text_size, 
              fontface = 'bold') +
    scale_color_gradientn(colors = hcl.colors(200, 'RdBu'),
                          limits = c(-1, 1),
                          breaks = c(1, 0.8, 0.6, 0.4, 0.2, 0, -0.2, -0.4, -0.6, -0.8, -1),
                          labels = c(1, 0.8, 0.6, 0.4, 0.2, 0, -0.2, -0.4, -0.6, -0.8, -1)) +
    guides(color = guide_colorbar(barwidth = 1,
                                  barheight = legend_barheight)) +
    scale_x_discrete(position = 'top') +
    theme(axis.text = element_text(color = 'red'),
          axis.ticks = element_blank(),
          axis.title = element_blank(),
          panel.grid.major = element_blank(),
          panel.grid.minor = element_blank(),
          panel.border = element_blank(),
          axis.text.x = element_text(angle = 90, hjust = 0),
          legend.frame = element_rect(color = 'black', linetype = 'solid', linewidth = 0.5),
          legend.ticks = element_blank(),
          legend.text = element_text(size = legend_text_size),
          legend.title = element_blank(),
          legend.box.spacing = unit(legend_box_spacing, 'cm'))
  
  ## creating list of outputs
  my_list <- list(CorrMatrix = corr_matrix,
                  CorrPlot = corr_plot)
  return(my_list)
}
```

**File paths**
```{r}
comb_table_fp <- '../crispr_screen_out/count_output/allSample_counts_long.tsv'
```

**Reading in count file**
reads in .tsv file and edits the sampleid column to only include the sampleid
```{r}
comb_table <- read_tsv(comb_table_fp)

comb_table$sampleid <- gsub("*_counts.txt", "", comb_table$sampleid)
```

## **CPM normalization**
**Combining all the count tables and normalizing them**
they're now in counts per million 
- create another data frame where we collapse the reads per gene - put these through the same downstream analysis/plots 
- the gene is the first part of the guide before the underscore in the #ID column 
- number of counts by guide and number of counts by gene (do both for raw and then normalize them)
```{r}
comb_counts <- comb_table %>% 
  rename(sgRNA_id = `#ID`) %>% 
  select(sgRNA_id, Plus_reads, sampleid) %>% 
  separate_wider_delim(cols = sgRNA_id,
                       delim = "_",
                       names = c("gene_id"),
                       cols_remove = FALSE,
                       too_many = 'drop')

comb_counts
```

**Normalizing count tables**
for sgRNA ids 
```{r}
sgCount_table_out <- normalize_table(comb_table = comb_counts,
                                     id_col = 'sgRNA_id')

sgRNA_combCounts_wide_df <- sgCount_table_out$NonNormTable
sgRNAnorm_combCounts_df <- sgCount_table_out$NormTable
```

for individual genes
```{r}
geneCount_table_out <- normalize_table(comb_table = comb_counts,
                                       id_col = 'gene_id')

gene_combCounts_wide_df <- geneCount_table_out$NonNormTable
geneNorm_combCounts_df <- geneCount_table_out$NormTable
```

```{r}
read.table('../crispr_screen_out/count_output/norm-cpm_allSample_sgRNAcounts.tsv')
```


## **PCA analysis**
**Calculating PCA**
- need to make sure that data is scaled and centered automatically by pca calculation function 
- need to transpose the normalized counts before they go into prcomp() function 

**PCA plot**
- need to have biological category parameter for the pca plot eventually (want to see the biological replicates cluster together) - need to be colored by this (biological_group)
- may save these as an .rdat object as well (for us) - put the raw and normalized (filtered) counts tables, pca obj

for sgRNA ids
```{r, fig.width=8, fig.height=4}
sgRNA_pca_res <- run_pca(norm_df = sgRNAnorm_combCounts_df,
                         sample_col = 'sampleid',
                         fill_by_col = 'sampleid',
                         point_size = 3,
                         point_alpha = 0.6,
                         brewer_palette = 'Dark2',
                         legend_title = 'Sample',
                         plot_title = 'sgRNA Count PCA')

sgRNA_count_pcaTable <- sgRNA_pca_res$PCATable
sgRNA_pca_plot <- sgRNA_pca_res$PCAPlot

sgRNA_pca_plot
```

for individual genes
```{r, fig.width=8, fig.height=4}
gene_pca_res <- run_pca(norm_df = geneNorm_combCounts_df,
                        sample_col = 'sampleid',
                        fill_by_col = 'sampleid',
                        point_size = 3,
                        point_alpha = 0.6,
                        brewer_palette = 'Dark2',
                        legend_title = 'Sample',
                        plot_title = 'Gene Count PCA')

gene_count_pcaTable <- gene_pca_res$PCATable
gene_pca_plot <- gene_pca_res$PCAPlot

gene_pca_plot
```

## **Total counts plot**
**Calculating total sgRNA/gene counts per sample**
don't need to do individual ones for sgRNA and gene bc they add up to the same thing!
- colored by biological group
- make a copy of the fastqs as fake data 
- create fake metadata file to set up r scripts 
```{r, fig.width=9.5, fig.height=7}
total_counts_res <- run_total_counts(comb_table = comb_counts,
                                     sum_col = 'sampleid',
                                     bar_alpha = 0.6,
                                     brewer_palette = 'Dark2',
                                     x_label = 'Sample',
                                     y_label = 'Total Counts',
                                     plot_title = 'Total sgRNA/Gene Counts per Sample')

total_counts_table <- total_counts_res$TotalCountTable
total_counts_plot <- total_counts_res$TotalCountPlot

total_counts_plot
```

## **Transformed sgRNA reads plot**
**log2 transformed sgRNA reads plot**
I think its log2 transformed?
```{r, fig.width=9.5, fig.height=7}
transform_count_res <- run_transform_counts(comb_table = comb_counts,
                                            x_axis_col = 'sampleid',
                                            bar_alpha = 0.6,
                                            brewer_palette = 'Dark2',
                                            x_label = 'Sample',
                                            y_label = 'log2(Counts)',
                                            plot_title = 'Transformed sgRNA/Gene Counts')

transform_counts_table <- transform_count_res$TransformCountTable
transform_counts_plot <- transform_count_res$TransformCountPlot

transform_counts_plot
```

## **Correlation matrix by sample**
**Calculating correlation matrix**
- currently defaulting to pearson correlation, run with both spearman and pearson correlation calculations for now!!
- pearson doesn't rank samples, makes assumption of continuous variables
- spearman ranks things (guides) first and compares correlation of the ranking to that of all the other samples (biological replicates should have similar ranking) - deals w ranking rather than actual normalized values 
- use the spearman correlation!!!

**Correlation matrix plot by sample**
- i cannot figure out how to make the tick marks go to the labels on the legend so i'm just going to go cry about it 
- if you change the dimensions, you HAVE to change the height of the legend bar (which is really annoying)


for sgRNA ids
```{r, fig.width=10, fig.height=8}
sgRNA_corr_res <- run_correlation(wide_count_df = sgRNA_combCounts_wide_df,
                                  corr_method = 'spearman',
                                  text_size = 5,
                                  legend_barheight = 23.6,
                                  legend_text_size = 12,
                                  legend_box_spacing = -0.3)

sgRNA_corr_matrix <- sgRNA_corr_res$CorrMatrix
sgRNA_corr_plot <- sgRNA_corr_res$CorrPlot

sgRNA_corr_plot
```

for individual genes
```{r, fig.width=10, fig.height=8}
gene_corr_res <- run_correlation(wide_count_df = gene_combCounts_wide_df,
                                 corr_method = 'spearman',
                                 text_size = 5,
                                 legend_barheight = 23.6,
                                 legend_text_size = 12,
                                 legend_box_spacing = -0.3)

gene_corr_matrix <- gene_corr_res$CorrMatrix
gene_corr_plot <- gene_corr_res$CorrPlot

gene_corr_plot
```

## **Saving my outputs**
**Files**
```{r}
## combined counts table in long format
write_tsv(comb_counts,
          '../crispr_screen_out/count_output/allSample_counts_long.tsv')

## sgRNA ids
## have to use write.table() to keep rownames in the .tsv files since write_tsv doesn't include them 
## combined counts table in wide format
write.table(sgRNA_combCounts_wide_df,
            '../crispr_screen_out/count_output/allSample_sgRNAcounts_wide.tsv',
            sep = "\t",
            row.names = TRUE)

## normalized combined counts table in wide format
write.table(sgRNAnorm_combCounts_df,
            '../crispr_screen_out/count_output/norm-cpm_allSample_sgRNAcounts.tsv',
            sep = "\t",
            row.names = TRUE)

## gene ids
## combined counts table in wide format
write.table(gene_combCounts_wide_df,
            '../crispr_screen_out/count_output/allSample_geneCounts_wide.tsv',
            sep = "\t",
            row.names = TRUE)

## normalized combined counts table in wide format
write.table(geneNorm_combCounts_df,
            '../crispr_screen_out/count_output/norm-cpm_allSample_geneCounts.tsv',
            sep = "\t",
            row.names = TRUE)
```

**Plots**
```{r}
ggsave('../crispr_screen_out/plots/sgRNACount_PCA_plot.pdf',
       plot = sgRNA_pca_plot,
       width = 8,
       height = 4)
ggsave('../crispr_screen_out/plots/geneCount_PCA_plot.pdf',
       plot = gene_pca_plot,
       width = 8,
       height = 4)
ggsave('../crispr_screen_out/plots/sample_totalCount_plot.pdf',
       plot = total_counts_plot,
       width = 9.5,
       height = 7)
ggsave('../crispr_screen_out/plots/sample_transCounts_plot.pdf',
       plot = transform_counts_plot,
       width = 9.5,
       height = 7)
ggsave('../crispr_screen_out/plots/sgRNACount_correlationMatrix.pdf',
       plot = proc_sgRNA_corr_plot,
       width = 10,
       height = 8)
ggsave('../crispr_screen_out/plots/geneCount_correlationMatrix.pdf',
       plot = proc_gene_corr_plot,
       width = 10,
       height = 8)

## saving all plots as a .png to create the report
ggsave('../report/plots/sgRNACount_PCA_plot.png',
       plot = sgRNA_pca_plot,
       width = 8,
       height = 4)
ggsave('../report/plots/geneCount_PCA_plot.png',
       plot = gene_pca_plot,
       width = 8,
       height = 4)
ggsave('../report/plots/sample_totalCount_plot.png',
       plot = total_counts_plot,
       width = 9.5,
       height = 7)
ggsave('../report/plots/sample_transCounts_plot.png',
       plot = transform_counts_plot,
       width = 9.5,
       height = 7)
ggsave('../report/plots/sgRNACount_correlationMatrix.png',
       plot = sgRNA_corr_plot,
       width = 10,
       height = 8)
ggsave('../report/plots/geneCount_correlationMatrix.png',
       plot = gene_corr_plot,
       width = 10,
       height = 8)
```
testing
```{r}
ggsave('../report/plots/test_plot.png',
       plot = sgRNA_pca_plot)
```

